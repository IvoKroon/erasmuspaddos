<html>
<head>
    <title>Strings Test</title>
    <style type="text/css">

        * {
            padding: 0;
            margin: 0;
        }

        body {
            background-color: #101010;
            height: 100%;
            color: #424242;
            text-align: center;
            font-size: 24px;
            font-family: 'Helvetica',sans-serif;
        }

        #wrapper {
            position: relative;
            width: 100%;
        }

        #stage {
            position: absolute;
            width: 100%;
            height: 700px;
            z-index: 10;
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        #strings {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 9;
        }

    </style>
</head>
<body>
    <div id="wrapper">
        <div id="stage"></div>
        <canvas id="strings" width="1280px" height="700px" style="background:#101010;"></canvas>
    </div>

<script src="//js.leapmotion.com/leap-0.6.4.js"></script>
<script>
    window.requestAnimFrame = (function() {
        return  window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function(callback) {
                    window.setTimeout(callback, 1000 / 60);
                };
    })();




    function Stage(id) {
        this.el = document.getElementById(id);
        this.position();
        this.listeners();
        this.hitZones = [];

        return this;
    }

    Stage.prototype.position = function() {
        var offset = this.offset();
        this.positionTop = Math.floor(offset.left);
        this.positionLeft = Math.floor(offset.top);
    };

    Stage.prototype.offset = function() {
        var _x, _y,
            el = this.el;

        if (typeof el.getBoundingClientRect !== "undefined") {
            return el.getBoundingClientRect();
        } else {
            _x = 0;
            _y = 0;

            while(el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {
                _x += el.offsetLeft;
                _y += el.offsetTop;
                el = el.offsetParent;
            }

            return { top: _y - window.scrollY, left: _x - window.scrollX };
        }
    };

    Stage.prototype.listeners = function() {
        var that = this;

        that.dragging = false;
        that.limit = false;


        window.addEventListener('resize', function() {
            that.position();
        }, false);


        window.addEventListener('scroll', function() {
            that.position();
        }, false);


        this.el.addEventListener('mousemove', function(e) {
            var x = e.clientX - that.positionTop,
                y = e.clientY - that.positionLeft;

            that.hitZones.forEach(function(zone) {
                that.checkPoint(x, y, zone);
            });

            that.dragging = true;
            that.prev = [x, y];
        }, false);


        document.addEventListener('mousemove', function(e) {
            var x, y;

            if (!that.dragging || that.limit)
                return;

            that.limit = true;

            x = e.clientX - that.positionTop;
            y = e.clientY - that.positionLeft;

            that.hitZones.forEach(function(zone) {
                that.checkIntercept(that.prev[0], that.prev[1], x, y, zone);
            });

            that.prev = [x, y];


            setInterval(function() {
                that.limit = false;
            }, 50);
        }, false);


        document.addEventListener('mouseover', function(e) {
            var x, y;

            if (!that.dragging)
                return;

            that.dragging = false;

            x = e.clientX - that.positionTop;
            y = e.clientY - that.positionLeft;

            that.hitZones.forEach(function(zone) {
                that.checkIntercept(that.prev[0], that.prev[1], x, y, zone);
            });
        }, false);
    };

    Stage.prototype.check = function(x, y, zone) {
        if (!zone.el)
            return;

        if (zone.inside(x, y)){
            zone.el.classList.add('hit');
            this.el.classList.add('active');
        } else {
            zone.el.classList.remove('hit');
            this.el.classList.remove('active');
        }
    };

    Stage.prototype.addRect = function(id) {
        var el = document.getElementById(id),
            rect = new Rect(el.offsetLeft,
                            el.offsetTop,
                            el.offsetWidth,
                            el.offsetHeight
                       );
        rect.el = el;

        this.hitZones.push(rect);

        return rect;
    };

    Stage.prototype.addString = function(rect, string) {
        rect.string = string;

        this.hitZones.push(rect);
        return rect;
    };

    Stage.prototype.checkPoint = function(x, y, zone) {
        if (zone.inside(x, y)) {
            zone.string.strum();
        }
    };

    Stage.prototype.checkIntercept = function(x1, y1, x2, y2, zone) {
        if (zone.intercept(x1, y1, x2, y2)) {
            zone.string.strum();
        }
    };




    function Rect(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        return this;
    }

    Rect.prototype.inside = function(x,y) {
        return x >= this.x && y >= this.y
                 && x <= this.x + this.width
                 && y <= this.y + this.height;
    };

    Rect.prototype.midLine = function() {
        if (this.middle)
            return this.middle;

        this.middle = [
            {x: this.x, y: this.y + this.height / 2},
            {x: this.x + this.width, y: this.y + this.height / 2}
        ];

        return this.middle;
    };

    Rect.prototype.intercept = function(x1, y1, x2, y2) {
        var segment = this.midLine(),
            start = {x: x1, y: y1},
            end = {x: x2, y: y2};

        return this.intersectLine(segment[0], segment[1], start, end);
    };

    //-- http://www.kevlindev.com/gui/math/intersection/Intersection.js
    Rect.prototype.intersectLine = function(a1, a2, b1, b2) {
        var ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
            ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
            u_b  = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);

        if (u_b != 0) {
            var ua = ua_t / u_b,
                ub = ub_t / u_b;

            if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
                return ua + ub;
            }
        } else {
            if (ua_t == 0 || ub_t == 0) {
                return false;   //-- Coincident
            } else {
                return false;   //-- Parallel
            }
        }
    };




    function HarpString(rect, id) {
        this.id = id + 1;
        this.x = rect.x;
        this.y = rect.y;
        this.width = rect.width;
        this.height = rect.height;
        this.sound = new Audio("sounds/Soundfiles/Toon" + this.id + ".mp3");
        this.sound.preload = "auto";
        this._strumForce = 0;
        this.a = 0;
    }

    HarpString.prototype.strum = function() {
        this._strumForce = 20;

        if (this.sound.ended) {
            this.sound.play();
        } else {
            if (this.sound.currentTime > 0) {
                this.sound.currentTime = 0.15;
            }
        }

        this.sound.play();
    };

    HarpString.prototype.stringColor = function(stringNum) {
        var red   = Math.floor(Math.sin(.3 * stringNum + 2) * 127 + 128),
            green = Math.floor(Math.sin(.3 * stringNum + 4) * 127 + 128),
            blue  = Math.floor(Math.sin(.3 * stringNum + 6) * 127 + 128);

        return "rgb(" + red + "," + green + "," + blue + ")";
    };

    HarpString.prototype.render = function(ctx, stringNum) {
        ctx.strokeStyle = this.stringColor(stringNum);
        ctx.lineWidth = 10;
        ctx.beginPath();

        // start point
        ctx.moveTo(this.x, this.y);
        ctx.bezierCurveTo(
            // first curve point
            this.x + Math.sin(this.a) * this._strumForce,
            this.y + this.height * 0.3,

            // second curve point
            this.x + Math.sin(this.a) * this._strumForce,
            this.y + this.height * 0.6,

            // end point
            this.x,
            this.y + this.height
        );
        ctx.stroke();

        this._strumForce *= 0.99;
        this.a += 0.8;
    };




//    function Hands() {
//        this.controller = new Leap.Controller();
//
//        return this;
//    }

    function StringInstrument(stageID, canvasID, stringNum) {
        this.strings = [];
        this.stage = new Stage(stageID);
        this.stringNum = stringNum;

        this.canvas = document.getElementById(canvasID);
        this.ctx = this.canvas.getContext('2d');

        this.hands = [];

//        this.clr = new Leap.Controller();
//        this.clr.connect();

        this.create();
        this.render();

        return this;
    }

    StringInstrument.prototype.create = function() {
        for (var i = 0; i < this.stringNum; i++) {
            var srect = new Rect(50 + i * 78, 0, 10, 700);
            var s     = new HarpString(srect, i);

            this.stage.addString(srect, s);
            this.strings.push(s);
        }
    };

    StringInstrument.prototype.renderLM = function() {
//        this.clr.on("frame", function(frame) {
//            if (frame.pointables.length > 0) {
//
//            }
//        });

//        var controller = new Leap.Controller();
//        controller.on("frame", function(frame) {
//            if (frame.pointables.length > 0) {
//                var canvasElement = this.canvas,
//                    ctx = this.ctx;
//
//                for (var i = 0, len = frame.hands.length; i < len; i++) {
//                    //clear
//                    canvasElement.width = canvasElement.width;
//
//                    //Get a pointable (hand) and normalize the index finger's dip position
//                    var hand = frame.hands[i];
//                    var interactionBox = frame.interactionBox;
//                    var normalizedPosition = interactionBox.normalizePoint(hand.indexFinger.dipPosition, true);
//
//                    // Convert the normalized coordinates to span the canvas
//                    handInfo[i][0] = canvasElement.width * normalizedPosition[0];
//                    handInfo[i][1] = canvasElement.height * (1 - normalizedPosition[1]);
//                    handInfo[i][2] = (canvasElement.width + canvasElement.height) * normalizedPosition[2];
//
//                    // loop through all objects and displayAreas
//                    for (var j = 0, len2 = frame.hands.length; j < len2; j++) {
//
//                        // only display within the canvas area
//                        if (handInfo[j][0] > 0 &&
//                                handInfo[j][0] < canvasElement.width &&
//                                handInfo[j][2] < 900) {
//                            var x = handInfo[j][0];
//                            var y = handInfo[j][1];
//                            var z = handInfo[j][2];
//
//                            // create circle and position it
//                            ctx.beginPath();
//                            ctx.arc(x, y, 25, 25, 0, 2 * Math.PI);
//
//                            // set opacity according to Z value
//                            displayOpacity = 1.72 - 0.0018 * z;
//
//                            ctx.fillStyle = "rgba(0, 0, 0, " + displayOpacity + ")";
//                            ctx.fill();
//
//                            // make circle green if we are in the "touch area"
//                            if (displayOpacity >= 1) {
//                                ctx.fillStyle = "rgba(0, 255, 150, 1)";
//                                ctx.fill();
//                            }
//                        }
//                    }
//                }
//            }
//        });
//        controller.connect();
    };

    StringInstrument.prototype.render = function() {
        var that = this;

        requestAnimFrame(function() {
            that.renderLM();
            that.render();
        });

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        for (var i = 0; i < this.stringNum; i++) {
            this.strings[i].render(this.ctx, i);
        }
    };

    var harp = new StringInstrument("stage", "strings", 16);
</script>
</body>

</html>









